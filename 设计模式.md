# 第十六章 设计模式

## 如何实现可修改性, 可扩展性, 灵活性
1. 需要进行接口和实现的分离, 通过接口和实现该接口的类, 通过子类继承父类
2. 利用抽象类机制实现可修改性和可扩展性
3. 利用委托机制实现灵活性: 继承的缺陷, 一旦一个对象被创建完成, 它的类型就无法改变, 这使得单纯利用继承机制无法实现灵活性(类型的动态改变)


## 策略模式
1. 首先可以把上下文和策略分割为不同的类, 实现不同的职责. 上下文Context类负责通过执行策略实现自己的职责, 而策略类Strategy只负责复杂策略的实现
2. 其次, 上下文类和策略类之间的关系是用组合代替继承
3. 最后, 各种策略则在具体策略类中提供, 而向上下文类提供统一的策略接口

## 抽象工厂模式
1. 简单工厂: 使用一个工厂对象, 通过if-else等方式实例化需要的对象
2. 工厂方法: 一个抽象方法creator(可在原来的类中), 使用子类继承creator所在的类通过实现creator方法来实例化需要的对象(实例化推迟到子类)
3. 抽象工厂: 为应对灵活性要求, 提供两套接口
   1. 一是表现出稳定的工厂行为的工厂接口
   2. 二是表现出稳定的产品行为的产品接口

## 单件模式(单例模式)
1. 为了实现只创建一个对象, 首先要让类的构造方法变为私有的
2. 只能通过getInstance方法获得对象的引用

## 迭代器模式
1. 对于遍历这件事, 主要有两个行为
   1. 是否有下一个元素
   2. 得到下一个元素
2. 所以设计迭代器接口```hasNext()```和```next()```
3. 迭代器提供的方法只提供了对集合的访问方法, 屏蔽了对集合修改的方法, 可以做到对集合"值传递"的效果