# 第十三章 详细设计中的模块化与信息隐藏

## 名词解释 耦合
1. 耦合: 描述的是两个模块之间的关系的复杂程度
2. 根据其耦合性由高到低分为几个级别: 模块耦合性越高, 模块的划分越差, 越不利于软件的变更和重用
   1. 内容耦合: 一个模块直接修改另一个模块的内容
   2. 公共耦合: 全局变量, 模块间共享全局数据
   3. 重复耦合: 模块间有重复代码
   4. 控制耦合: 一个模块给另一个模块传递控制信息
   5. 印记耦合: 共享数据结构却只是用了一部分
   6. 数据耦合: 模块间传参只传需要的数据, 最理想
3. 1,2,3不可接受, 4,5可接受, 6最理想

## 名词解释 内聚
1. 内聚: 表达的是一个模块内部的联系的紧密性
2. 内聚性由高到低分为
   1. 信息内聚: 模块进行许多操作, 各自有各自的入口点, 每个操作代码相对独立, 而且所有操作都在相同的数据结构上进行
   2. 功能内聚: 只执行一个操作或达到一个目的
   3. 通信内据: 对相同数据执行不同的操作
   4. 过程内聚: 与步骤有关
   5. 时间内聚: 与时间有关
   6. 逻辑内聚: 一系列可替换的操作
   7. 偶然内聚: 多个不相关的操作
3. 3,4,5等价, 1,2最好, 6,7不能接受
   

## 信息隐藏基本思想
1. 每个模块都隐藏一个重要的设计决策, 职责
2. 职责体现为模块对外的一份契约, 并且在这份契约之下隐藏的只有这个模块知道的决策或者说秘密, 决策的实现细节仅自己知道
3. 所谓的秘密(容易变更的地方): 根据需求分配的职责, 内部实现机制

# 第十四章 详细设计中面向对象方法下的模块化

## 模块化的原则
1. 全局变量是有害的
2. 显示: 代码清晰, 不进行不必要的隐藏, 但可能与可修改性冲突
3. 不要有代码重复
4. 针对接口编程
5. 迪米特法则: 不要出现```a.b.method()```
6. 接口分离原则: 将一个统一的接口匹配为多个更独立的接口
7. Liskov替换原则
8. 使用组合代替继承
9. 单一职责原则
10. 1,2,3 针对降低隐式耦合, 4,5,6 针对降低访问耦合, 7,8 针对降低继承耦合, 9和信息专家原则用于提高继承内聚


# 第十五章 详细设计中面向对象方法下的信息隐藏

## 封装
1. 含义1: 数据与行为集中在一起
2. 含义2: 接口与实现相分离, 接口是类的外部表现, 对外公开; 实现是类的内部结果, 内部隐藏
3. 封装的初始观点: 把数据(内部结构)隐藏在抽象数据类型内
4. 新观点(信息隐藏): 隐藏任何东西
5. 封装数据与行为
6. 封装结构
7. 封装其他对象
8. 封装子类
9. 封装潜在变更

## 开闭原则OCP
1. 对扩展开放, 对修改封闭
2. 违反了OCP原则的典型标志: 出现switch或if-else
3. 分支让程序增加复杂度, 修改时容易产生新错误

## 依赖倒置原则DIP
1. 高层模块不应该依赖底层模块, 两者都应依赖抽象
2. 抽象不应依赖细节, 细节应依赖抽象
3. 使用抽象类倒置依赖