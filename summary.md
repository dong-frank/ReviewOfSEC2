# summary

## 名词解释
1. 软件工程
   1. 应用系统的、规范的、可量化的方法，来开发、运行和维护软件，即将工程运用到软件开发中
   2. 是对软件开发中系统的、规范的、可量化的方法的研究
2. 需求
   1. 用户为了解决问题或达到某些目标所需要的条件或能力
   2. 系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求而需要具备的条件或能力
   3. 对上述的条件或能力的一种文档化表述
3. 软件设计
   1. 为使软件系统满足规定的需求而定义系统或部件的体系结构, 部件, 接口和其他特征的过程
   2. 设计过程的结果
4. 易用性
   1. 易用性是人机交互中一个既重要又复杂的概念
   2. 不仅关注人使用系统的过程, 同时还关注系统对使用它的人所产生的作用
   3. 易用性不是一个单一的质量维度, 而是多维度的质量属性
   4. 从易于度量的角度考虑, 易用性常用维度包括: 易学性, 易记性, 有效率, 低出错率和主观满意度
5. 耦合
   1. 描述的是两个模块之间的关系的复杂程度
6. 内聚
   1. 表达的是一个模块内部的联系的紧密性
7. 重构
   1. 修改软件系统的严谨方法, 在不改变代码外部表现的情况下改进其内部结构
9. 测试驱动开发
   1. 要求程序员在编写一段代码之前, 优先完成该段代码的测试代码
   2. 测试代码之后, 再编写程序代码, 并在编程中重复执行测试代码, 以验证程序代码的正确性
10. 结对编程
   1. 两个程序员挨坐在一起, 共同协作进行软件构造活动
11. 持续集成的好处及工具链
    1. 降低风险, 对系统健康进行持续检查, 减少重复性工作, 持续部署, 持续交付, 增加团队成员信心
    2. 工具链: 版本控制工具和持续集成工具
12. 软件生命周期
    1. 需求工程
    2.  软件设计
    3.  软件实现
    4.  软件测试
    5.  软件交付
    6.  软件维护 
13. 从1950s-2000s软件开发的特点
    1. 1950s 科学计算; 以机器为中心进行编程; 像生产硬件一样生产软件
    2.  1960s 业务应用（批量数据处理和事物计算）; 软件不同于硬件; 用软件工艺的方法生产软件
    3.  1970s 结构化方法; 瀑布模型; 强调规则和纪律。它们奠定了软件工程的基础，是后续年代软件工程发展的支撑
    4.  1980s **追求生产力最大化**; 现代结构化方法/面向对象编程广泛应用; 重视过程的作用
    5.  1990s 企业为中心的大规模软件系统开发; 追求快速开发、可变更性和用户价值; web应用出现
    6.  2000s 大规模web应用; 大量面向大众的web产品; 追求快速开发、可变更性、用户价值和创新
    7.  2010s - now 云原生; 众; 打数据; AI; 短视频; web3.0

## 需求题

### 根据材料分析用例, 指出参与者和主要流程
用例描述了为应对一个业务事件, 由一个用户发起, 并在一个连续时间段内完成, 可以增加业务价值的任务

常见错误
- **不要将没有业务价值(而是技术实现需要)的事件作为用例**
- 不要将用例细化为单个操作
- 不要将单个步骤细化为用例
- 不要将片面的一个方向细化为用例

### 根据材料分析需求的三个层次
需求的三个层次
1. 业务需求： 来自现实，是系统建立的战略出发点，表现为高层次的目标，**它描述了组织为什么要开发系统**，为了满足用户的业务需求，需求工程师需要描述系统高层次的解决方案，定义系统应该具备的特性
2. 用户需求： 来自现实，执行实际工作的用户对系统所能完成的具体任务的期望，描述了系统能够**帮助用户做些什么**。对所有的用户需求，都应该有充分的问题域知识作为背景支持 **是模糊的, 不清晰的, 多特性混杂, 多逻辑混杂**
3. 系统级需求： 来自软件，用户对系统行为的期望，每个系统级需求反映了一次外界与系统的交互行为，或者系统的一个实现细节。描述了**开发人员需要实现什么**

### 根据材料分析需求类型/需求分类
需求类型
1. 项目需求: 人的数量, 成本, 时间
2. 过程需求: 人的分工, 合作, 方法, 工具
3. 系统需求
   1. 软件需求
   2. 硬件需求
   3. 其他需求
4. 不切实际的期望

需求分类
1. 功能需求: 用户希望系统所能够执行的活动, 主要表现为系统和环境之间的行为交互
2. 性能需求: 系统整体或组成部分应该拥有的性能特征
3. 质量属性: 系统完成工作的质量, 即系统需要在一个"好的程度"上实现功能需求
4. 对外接口: 包括硬件接口, 软件接口, 数据库接口
5. 约束: 例如一些商业规则
6. 数据需求: 对功能需求中未定义的数据结构的补充

## 需求分析题

### 通过名词分析法确定概念类
分析的步骤
1. 识别候选类
2. 从候选类中确定概念类(既有状态又有行为)
   1. 如果只需要状态, 而不需要行为: 是其他概念类的属性
   2. 如果不需要状态, 却需要行为: 可能是需求的遗漏, 如果确定没有遗漏就剔除该候选类
   3. 不需要状态, 也不需要行为: 被完全剔除

### 识别概念类之间的关联
识别关联("名词" + "动词" + "名词" 的结构): 第一标准是满足需求的要求, 第二标准是现实状况

1. 继承
2. 依赖
3. 组合: 表示部分和整体之间的关系，但是要求两者必须是同时存在下才有意义的
4. 聚合: 表示两个对象可以分开存在，存在部分和整体的关系
5. 关联

### 识别重要属性


### 绘制概念类图(分析类图)
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/18.png)
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/19.png)


- 空心三角形表示继承
- 实心菱形表示组合
- 空心菱形表示聚合
- 实线表示关联
- 在方框中补充重要属性

## 体系结构设计题

### 绘制物理包图
首先要明确使用哪种体系结构风格
1. 主程序/子程序
2. 面向对象式
3. 分层
4. MVC

包图包括包的名称和包与包的关系
1. 包的名称
![alt text](/assets/image4.png)
2. 包与包的关系
   1. 依赖和继承

### 设计接口
1. 根据分配的需求确定模块对外接口, 如逻辑层接口根据页面的需求得到, 数据层接口根据逻辑层调用得到 PO和VO
2. 根据刺激与响应确定接口, 依据详细规格明确接口内容

## 详细设计题

### 需求变更
例题
![alt text](/assets/image5.png)

- 这是一种参数化变更
- 通过参数化设计来应对变更


### 绘制具体的类图
在概念类图的基础上补充方法和属性的定义
- "+" 表示公有
- "-" 表示私有

### 绘制顺序图
步骤
1. 确定上下文环境
2. 根据用例描述找到交互的对象
3. 按照用例描述中的流程顺序逐步添加消息

![alt text](/assets/image1.png)

注意
1. 异步消息的箭头无论是从用户到系统还是从系统到用户都是一样的
2. opt标签表示可选
3. loop标签表示循环, 要在旁边用```[]```内写循环条件
4. alt标签表示候选分支(基本上只会放一次返回消息), 每一种可选分支之间要用虚线分割, 而且在表示执行态的圆柱上面写条件
![alt text](/assets/image2.png)

## 详细设计题

### 区分耦合类型

1. 内容耦合: 一个模块直接修改另一个模块的内容
2. 公共耦合: 全局变量, 模块间共享全局数据
3. 重复耦合: 模块间有重复代码
4. 控制耦合: 一个模块给另一个模块传递控制信息
5. 印记耦合: 共享数据结构却只是用了一部分
6. 数据耦合: 模块间传参只传需要的数据, 最理想

![alt text](/assets/image6.png)
印记耦合, ```valid_month()```只用了```date```中的```month```

修改: 将```valid_month()```接受的参数改为```int month```


![alt text](/assets/image7.png)
控制耦合, 传递了一个控制标志

修改: 将```valid()```职责进行拆分


## 设计模式题

### 选择合适的设计模式实现对应功能
设计模式及设计原则
1. 策略模式
   1. 开闭原则
   2. 单一职责原则
   3. 依赖倒置原则
   4. 封装变化原则
2. 抽象工厂模式
   1. 开闭原则
   2. 单一职责原则
   3. 依赖倒置原则
   4. 接口隔离原则
3. 单例模式
   1. 单一职责原则
   2. 封装原则
   3. 最小知识原则
4. 迭代器模式
   1. 开闭原则
   2. 单一职责原则
   3. 接口隔离原则
   4. 封装原则

所有设计模式都服务于"高内聚低耦合"的核心目标


## 软件构造题
对代码进行重构

## 人机交互题

### 结合页面说明体现了哪些人机交互的设计原则
1. 简洁设计(7±2原则)：文字不如图形
2. 一致性设计(实际模型和人的精神模型一致)，如下是一个不一致的例子(cancel和ok的位置问题)
3. 低出错率设计(包括不适当的菜单功能灰色屏蔽、检查输入，出现错误的时候帮助用户修正错误，而不是重新填写，每一个输入都尽快的显示问题)
4. 易记性设计
   1. 减少短期记忆的负担
   2. 使用逐层递进的方式展示信息
   3. 使用直观的快捷方式
   4. 设置有意义的默认值
5. 可视化设计
   1. 按照任务模型设计界面隐喻，同时不要把软件系统的内部构造机制暴露给用户
   2. 可视化设计还应该基于界面隐喻，尽可能地把功能和任务细节表现出来。

## 测试题

### 设计测试样例
注意区分是黑盒还是白盒

白盒的测试有三种不同的方法
1. 语句覆盖: 确保被测试对象的每一行程序代码都至少执行一次
2. 条件覆盖: 确保程序中每个判断的每个结果都至少满足一次
3. 路径覆盖: 确保程序中每条独立的执行路径都至少执行一次

黑盒测试只需要给出输入, 测试输出是否和预期一致


注意测试一些极端值和一些可能会引发错误的值