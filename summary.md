# summary

## 名词解释
1. 软件工程
   1. 应用系统的、规范的、可量化的方法，来开发、运行和维护软件，即将工程运用到软件开发中
   2. 是对软件开发中系统的、规范的、可量化的方法的研究
2. 需求
   1. 用户为了解决问题或达到某些目标所需要的条件或能力
   2. 系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求而需要具备的条件或能力
   3. 对上述的条件或能力的一种文档化表述
3. 软件设计
   1. 为使软件系统满足规定的需求而定义系统或部件的体系结构, 部件, 接口和其他特征的过程
   2. 设计过程的结果
4. 易用性
   1. 易用性是人机交互中一个既重要又复杂的概念
   2. 不仅关注人使用系统的过程, 同时还关注系统对使用它的人所产生的作用
   3. 易用性不是一个单一的质量维度, 而是多维度的质量属性
   4. 从易于度量的角度考虑, 易用性常用维度包括: 易学性, 易记性, 有效率, 低出错率和主观满意度
5. 耦合
   1. 描述的是两个模块之间的关系的复杂程度
   2. 内容耦合: 一个模块直接修改另一个模块的内容
   3. 公共耦合: 全局变量, 模块间共享全局数据
   4. 重复耦合: 模块间有重复代码
   5. 控制耦合: 一个模块给另一个模块传递控制信息
   6. 印记耦合: 共享数据结构却只是用了一部分
   7. 数据耦合: 模块间传参只传需要的数据, 最理想
6.  内聚
    1. 表达的是一个模块内部的联系的紧密性
    2. 信息内聚: 模块进行许多操作, 各自有各自的入口点, 每个操作代码相对独立, 而且所有操作都在相同的数据结构上进行
    3. 功能内聚: 只执行一个操作或达到一个目的
    4. 通信内据: 对相同数据执行不同的操作
    5. 过程内聚: 与步骤有关
    6. 时间内聚: 与时间有关
    7. 逻辑内聚: 一系列可替换的操作
    8. 偶然内聚: 多个不相关的操作
7.  重构
    1. 修改软件系统的严谨方法, 在不改变代码外部表现的情况下改进其内部结构
8.  测试驱动开发
    1. 要求程序员在编写一段代码之前, 优先完成该段代码的测试代码
    2. 测试代码之后, 再编写程序代码, 并在编程中重复执行测试代码, 以验证程序代码的正确性
9.  结对编程
    1. 两个程序员挨坐在一起, 共同协作进行软件构造活动
10. 持续集成的好处及工具链
    1. 防⽌软件开发中出现⽆法集成与发布的情况。因为软件项⽬在任何时刻都是可以集成和发布的
    2. 有利于检查和发现集成缺陷
    3. 工具链: 版本控制工具和持续集成工具
11. 软件生命周期
    1. 一个特定软件系统的生命周期简要描述了该软件的开发活动简史
    2. 需求工程
    3. 软件设计
    4. 软件实现
    5. 软件测试
    6. 软件交付
    7. 软件维护 
12. 从1950s-2000s软件开发的特点
    1. 1950s 科学计算; 以机器为中心进行编程; 像生产硬件一样生产软件
    2. 1960s 业务应用（批量数据处理和事物计算）; 软件不同于硬件; 用软件工艺的方法生产软件
    3. 1970s 结构化方法; 瀑布模型; 强调规则和纪律。它们奠定了软件工程的基础，是后续年代软件工程发展的支撑
    4. 1980s 追求生产力最大化; 现代结构化方法/面向对象编程广泛应用; 重视过程的作用
    5. 1990s 企业为中心的大规模软件系统开发; 追求快速开发、可变更性和用户价值; web应用出现
    6. 2000s 大规模web应用; 大量面向大众的web产品; 追求快速开发、可变更性、用户价值和创新
    7. 2010s - now 云原生; 众; 大数据; AI; 短视频; web3.0
13. 简述演化模型及其优缺点
    1.  将软件开发组织为多个迭代, 并行的瀑布式开发活动
    2.  对需求的反馈是演化模型进行迭代规划, 开发活动组织和控制的主要依据, 是需求驱动的
    3.  优点是使用了迭代开发, 具有更好的适用性; 并行开发可以帮助缩短软件产品的开发时间; 渐进交付可以加强用户反馈, 降低开发风险
    4.  缺点是无法在项目早期确定项目范围; 后期迭代的开发活动是在前导迭代的基础上进行修改和扩展的, 容易让后续迭代忽略分析与设计工作
14. 简述原型模型及其优缺点
    1.  通过需求驱动, 大量使用抛弃式原型, 通过模拟"未来"的产品, 将"未来"的知识置于"现在"进行推敲, 解决不确定性
    2.  优点是加强与用户沟通, 解决不确定性
    3.  缺点是成本高昂, 若抛弃式原型中较差的代码进入产品, 降低代码质量
15. 简述螺旋模型及其优缺点
    1.  是风险驱动的, 基本思想是想尽早解决比较高的风险
    2.  迭代与瀑布相结合, 开发过程是瀑布式的, 风险分析是迭代的
    3.  优点是降低风险, 减少因风险造成的损失
    4.  缺点是使用原型方法, 为自身带来风险; 模型过于复杂, 不利于管理者依据其组织开发活动
16. 简述增量迭代模型及其优缺点
    1.  项目开始时, 通过系统需求开发和核心体系结构设计完成项目的前景范围的界定
    2.  然后将后续活动组织为多个迭代的, 可并行的瀑布式开发活动
    3.  第一个迭代完成的往往是核心工作, 满足基本需求, 后续迭代完成附带特性
    4.  优点是更符合软件开发实践, 并行开发可以缩短产品开发时间, 渐进交付可以加强用户反馈, 降低开发风险
    5.  缺点是要求高, 软件需要开放式的体系结构; 不确定性太多, 导致难以在项目初期确定前景和范围 
17. 简述逆向工程与正向工程的区别, 并各用一句话说明其关注点
    1.  正向工程是从零开始、遵循需求规格说明书，通过设计、实现、测试等阶段逐步构建出新系统或产品的过程。它是“从无到有”的创造过程
    2.  逆向工程是从已有的、通常是成品的系统或产品出发，通过分析其结构、功能和行为，推导出其设计原理、规格说明甚至源代码的过程。它是“从有到知”的解构与分析过程
    3.  正向工程： 关注如何根据明确的需求和设计规范，系统地构建出新的、符合预期的系统或产品
    4.  逆向工程： 关注如何通过分析现有系统或产品的表现和结构，理解其工作机制、设计意图或恢复其缺失的文档/规格说明
18. 软件设计的核心思想
    1.  软件的复杂度控制
    2.  通过分解, 抽象和层次性来实现软件的复杂度控制
19. 演化式生命周期模型
    1.  初步开发
    2.  演化
    3.  服务
    4.  逐步淘汰
    5.  停止
20. 软件设计的SOLID原则
    1.  单一职责原则 SRP
    2.  开闭原则 OCP
    3.  里氏替换原则 LSP: 所有父类能出现的地方, 都能被替换为子类
    4.  接口隔离原则 ISP
    5.  依赖倒置原则 DIP
## 需求题

### 根据材料分析用例, 指出参与者和主要流程
四要素: 用例, 参与者, 关系, 系统边界

用例描述了为应对一个业务事件, 由一个用户发起, 并在一个连续时间段内完成, 可以增加业务价值的任务

建立用例图的步骤
1. 进行目标分析与确定解决方向
2. 寻找参与者
3. 寻找用例: 通过找到的参与者来寻找用例, 每个参与者的一个目标就是一个用例

常见错误
- **不要将没有业务价值(而是技术实现需要)的事件作为用例**
- 不要将用例细化为单个操作
- 不要将单个步骤细化为用例
- 不要将片面的一个方向细化为用例

### 根据材料分析需求的三个层次
需求的三个层次
1. 业务需求： 来自现实，是系统建立的战略出发点，表现为高层次的目标，**它描述了组织为什么要开发系统**，为了满足用户的业务需求，需求工程师需要描述系统高层次的解决方案，定义系统应该具备的特性
2. 用户需求： 来自现实，执行实际工作的用户对系统所能完成的具体任务的期望，描述了系统能够**帮助用户做些什么**。对所有的用户需求，都应该有充分的问题域知识作为背景支持 **是模糊的, 不清晰的, 多特性混杂, 多逻辑混杂**
3. 系统级需求： 来自软件，用户对系统行为的期望，每个系统级需求反映了一次外界与系统的交互行为，或者系统的一个实现细节。描述了**开发人员需要实现什么**

### 根据材料分析需求类型/需求分类
需求类型
1. 项目需求: 人的数量, 成本, 时间
2. 过程需求: 人的分工, 合作, 方法, 工具
3. 系统需求
   1. 软件需求
   2. 硬件需求
   3. 其他需求
4. 不切实际的期望

需求分类
1. 功能需求: 用户希望系统所能够执行的活动, 主要表现为系统和环境之间的行为交互
2. 性能需求: 系统整体或组成部分应该拥有的性能特征
3. 质量属性: 系统完成工作的质量, 即系统需要在一个"好的程度"上实现功能需求
4. 对外接口: 包括硬件接口, 软件接口, 数据库接口
5. 约束: 进行系统构造时需要遵守的约束, 例如编程语⾔、硬件设施等
6. 数据需求: 对功能需求中未定义的数据结构的补充

## 需求分析题

### 通过名词分析法确定概念类
分析的步骤
1. 识别候选类
2. 从候选类中确定概念类(既有状态又有行为)
   1. 如果只需要状态, 而不需要行为: 是其他概念类的属性
   2. 如果不需要状态, 却需要行为: 可能是需求的遗漏, 如果确定没有遗漏就剔除该候选类
   3. 不需要状态, 也不需要行为: 被完全剔除

### 识别概念类之间的关联
识别关联("名词" + "动词" + "名词" 的结构): 第一标准是满足需求的要求, 第二标准是现实状况

1. 继承
2. 依赖: 一个类使用到另一个类
3. 组合: 表示部分和整体之间的关系，但是要求两者必须是同时存在下才有意义的
4. 聚合: 表示两个对象可以分开存在，存在部分和整体的关系
5. 关联: 可以理解为拥有, 一个类知道另一个类的属性和方法

### 识别重要属性


### 绘制概念类图(分析类图)
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/18.png)
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/19.png)

![alt text](/assets/image8.png)
- 空心三角形表示继承
- 实心菱形表示组合
- 空心菱形表示聚合
- 实线表示关联
- 在方框中补充重要属性, 但不是全部的详细属性, 且属性没有类型约束, 也不会包含方法

## 体系结构设计题

### 绘制物理包图
首先要明确使用哪种体系结构风格
1. 主程序/子程序
2. 面向对象式
3. 分层
4. MVC

包图包括

![alt text](/assets/image4.png)
1. 包的名称
2. 包与包的关系
   1. 依赖和继承
3. 包内的元素
   1. 类和子包

分包原则
![alt text](/assets/image9.png)
   
### 设计接口
1. 根据分配的需求确定模块对外接口, 如逻辑层接口根据页面的需求得到, 数据层接口根据逻辑层调用得到 PO和VO
2. 根据刺激与响应确定接口, 依据详细规格明确接口内容

## 详细设计题

### 需求变更
例题
![alt text](/assets/image5.png)

- 这是一种参数化变更
- 通过参数化设计来应对变更


### 绘制具体的类图
在概念类图的基础上补充方法和属性的定义
- "+" 表示公有
- "-" 表示私有

### 绘制顺序图(交互图)
步骤
1. 确定上下文环境
2. 根据用例描述找到交互的对象
3. 按照用例描述中的流程顺序逐步添加消息

![alt text](/assets/image1.png)

注意
1. 异步消息的箭头无论是从用户到系统还是从系统到用户都是一样的
2. opt标签表示可选
3. loop标签表示循环, 要在旁边用```[]```内写循环条件
4. alt标签表示候选分支(基本上只会放一次返回消息), 每一种可选分支之间要用虚线分割, 而且在表示执行态的圆柱上面写条件
![alt text](/assets/image2.png)

![alt text](/assets/image10.png)


## 详细设计题

### 区分耦合类型

1. 内容耦合: 一个模块直接修改另一个模块的内容
2. 公共耦合: 全局变量, 模块间共享全局数据
3. 重复耦合: 模块间有重复代码
4. 控制耦合: 一个模块给另一个模块传递控制信息
5. 印记耦合: 共享数据结构却只是用了一部分
6. 数据耦合: 模块间传参只传需要的数据, 最理想

![alt text](/assets/image6.png)

印记耦合, ```valid_month()```只用了```date```中的```month```

修改: 将```valid_month()```接受的参数改为```int month```


![alt text](/assets/image7.png)

控制耦合, 传递了一个控制标志

修改: 将```valid()```职责进行拆分


## 设计模式题

### 选择合适的设计模式实现对应功能
设计模式及设计原则
1. 策略模式
   1. 开闭原则: 对扩展开放, 对修改封闭
   2. 单一职责原则
   3. 依赖倒置原则: 不依赖具体类而是依赖抽象
   4. 封装变化原则
![alt text](/assets/image11.png)
2. 抽象工厂模式
   1. 开闭原则
   2. 单一职责原则
   3. 依赖倒置原则
   4. 接口隔离原则
![alt text](/assets/image12.png)
![alt text](/assets/image13.png)
3. 单例模式: 对于某个类，在内存中只希望有唯一一个对象存在
   1. 单一职责原则
   2. 封装原则
   3. 最小知识原则
![alt text](/assets/image14.png)
4. 迭代器模式
   1. 开闭原则
   2. 单一职责原则
   3. 接口隔离原则
   4. 封装原则
![alt text](/assets/image15.png)
![alt text](/assets/image16.png)

所有设计模式都服务于"高内聚低耦合"的核心目标


## 软件构造题
对代码进行重构

表驱动编程


## 人机交互题

### 结合页面说明体现了哪些人机交互的设计原则
1. 简洁设计(7±2原则)：文字不如图形
2. 一致性设计(实际模型和人的精神模型一致)，如下是一个不一致的例子(cancel和ok的位置问题)
3. 低出错率设计(包括不适当的菜单功能灰色屏蔽、检查输入，出现错误的时候帮助用户修正错误，而不是重新填写，每一个输入都尽快的显示问题)
4. 易记性设计
   1. 减少短期记忆的负担
   2. 使用逐层递进的方式展示信息
   3. 使用直观的快捷方式
   4. 设置有意义的默认值
5. 可视化设计
   1. 按照任务模型设计界面隐喻，同时不要把软件系统的内部构造机制暴露给用户
   2. 可视化设计还应该基于界面隐喻，尽可能地把功能和任务细节表现出来。

## 测试题

### 设计测试样例
注意区分是黑盒还是白盒

白盒的测试有三种不同的方法
1. 语句覆盖: 确保被测试对象的每一行程序代码都至少执行一次
2. 条件覆盖: 确保程序中每个判断的每个结果都至少满足一次
3. 路径覆盖: 确保程序中每条独立的执行路径都至少执行一次

黑盒测试只需要给出输入, 测试输出是否和预期一致


注意测试一些极端值和一些可能会引发错误的值