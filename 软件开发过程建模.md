# 第二十二, 二十三章 软件开发过程建模

## 软件生命周期模型
1. 需求工程
2. 软件设计
3. 软件实现
4. 软件测试
5. 软件交付
6. 软件维护

## 解释与比较不同的软件过程模型

### 构建-修复模型
特征
1. 没有对开发过程进行规范和组织
2. 对需求的真实性没有进行分析
3. 没有考虑软件结构的质量, 导致结构在修改中越来越糟, 甚至无法修改
4. 没有考虑测试和程序的可维护性, 也没有任何文档导致难以维护

适用场景
1. 软件规模很小
2. 软件对质量的要求不高
3. 只关注开发活动, 对后期维护的要求不高


### 瀑布模型(文档驱动)
特征
1. 对于软件开发活动有明确阶段划分
2. 每个阶段的结果都必须验证, 使得该模型是"文档驱动"

优点
1. 清晰的阶段划分有利于开发者以关注点分离的方式更好的进行复杂软件项目的开发

缺点
1. 对文档期望过高
2. 对开发活动的线性顺序假设
3. 用户参与度不够, 因为需求被限制在需求工程阶段
4. 里程碑粒度过粗

适用场景
1. 需求非常成熟, 稳定, 没有不确定的内容, 也不会发生变化
2. 所需的技术成熟, 可靠, 没有不确定的技术难点
3. 复杂度适中, 不至于产生过大的文档负担和过粗的里程碑

### 增量迭代模型(需求驱动)与演化模型互为补充
特征
1. 项目开始时, 通过系统需求开发和核心体系结构设计活动完成项目的前景范围的界定
2. 然后将后续活动组织为多个迭代, 并行的瀑布式开发活动
3. 第一个迭代完成的往往是核心工作, 满足基本需求, 后续迭代完成附带特性

优点
1. 更符合软件开发实践
2. 并行开发可以缩短产品开发时间
3. 渐进交付可以加强用户反馈, 降低开发风险

缺点
1. 要求高, 软件需要开放式的体系结构
2. 不确定性太多, 导致难以在项目开始就确定前景和范围

适用场景
1. 比较成熟和稳定的领域


### 演化模型(需求驱动)
特征
1. 大量使用抛弃式原型, 通过模拟"未来"的产品, 将"未来"的知识置于"现在"进行推敲, 解决不确定性

优点
1. 加强与用户的交流, 更好的产品满意度

缺点
1. 成本较高, 有耗尽时间和费用的风险
2. 有人不舍得抛弃"抛弃式原型", 使得较差的代码进入产品, 降低质量

适用场景
1. 有着大量不确定性的新颖领域

### 螺旋模型(风险驱动)
特征
1. 基本思想是尽早解决比较高的风险, 如果有些问题实在无法解决, 那么早发现更好
2. 迭代与瀑布的结合, 开发阶段是瀑布式的, 风险分析是迭代的

优点
1. 降低风险, 减少因风险造成的损失

缺点
1. 使用原型方法, 为自身带来风险
2. 模型过于复杂, 不利于管理者依据其组织软件开发活动

适用场景
1. 高风险的大规模软件系统开发


## 软件工程知识体系的知识域
需求, 设计, 构造, 测试, 维护, 配置管理, 工程管理, 工程过程, 工程工具和方法, 质量